// Package oapigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package oapigen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Error defines model for Error.
type Error struct {
	Code    *int    `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
	Meta    *Meta   `json:"meta,omitempty"`
}

// Game defines model for Game.
type Game struct {
	EuSale     *float32 `json:"euSale,omitempty"`
	Genre      *string  `json:"genre,omitempty"`
	GlobalSale *float32 `json:"globalSale,omitempty"`
	JpSale     *float32 `json:"jpSale,omitempty"`
	NaSale     *float32 `json:"naSale,omitempty"`
	Name       *string  `json:"name,omitempty"`
	OtherSale  *float32 `json:"otherSale,omitempty"`
	Platform   *string  `json:"platform,omitempty"`
	Publisher  *string  `json:"publisher,omitempty"`
	Rank       *int     `json:"rank,omitempty"`
	Year       *int     `json:"year,omitempty"`
}

// Meta defines model for Meta.
type Meta struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PageMeta defines model for PageMeta.
type PageMeta struct {
	TotalCount int64 `json:"totalCount"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Maximum entities to return
	Limit *int64 `json:"limit,omitempty"`

	// The starting position of page
	Offset *int64 `json:"offset,omitempty"`
}

// Session defines model for Session.
type Session struct {
	// a JWT token with short lifetime which contains the necessary information about user and it's authorization.
	AccessToken string `json:"accessToken"`

	// Can be used to acquire new access tokens. Has a long expire time and MUST be stored in a secure place
	RefreshToken string `json:"refreshToken"`

	// Default type is always 'Bearer'
	TokenType string `json:"tokenType"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse Error

// SearchGamesByNameParams defines parameters for SearchGamesByName.
type SearchGamesByNameParams struct {
	Name *string `json:"name,omitempty"`
}

// SearchGamesBySoldParams defines parameters for SearchGamesBySold.
type SearchGamesBySoldParams struct {
	Pagination *Pagination `json:"pagination,omitempty" valid:"pagination"`
}

// GetTopGamesByGenreParams defines parameters for GetTopGamesByGenre.
type GetTopGamesByGenreParams struct {
	Count *int `json:"count,omitempty"`
}

// GetTopGamesByPlatformParams defines parameters for GetTopGamesByPlatform.
type GetTopGamesByPlatformParams struct {
	Count *int `json:"count,omitempty"`
}

// GetTopGamesParams defines parameters for GetTopGames.
type GetTopGamesParams struct {
	Pagination *Pagination `json:"pagination,omitempty" valid:"pagination"`
}

// GetMostSeledGamesByPlatformParams defines parameters for GetMostSeledGamesByPlatform.
type GetMostSeledGamesByPlatformParams struct {
	Platform *string `json:"platform,omitempty"`
	Year     *int    `json:"year,omitempty"`
}

// GetTopGamesByYearParams defines parameters for GetTopGamesByYear.
type GetTopGamesByYearParams struct {
	Count *int `json:"count,omitempty"`
}

// GetTotalSellByGenreParams defines parameters for GetTotalSellByGenre.
type GetTotalSellByGenreParams struct {
	Start  *int    `json:"start,omitempty"`
	End    *int    `json:"end,omitempty"`
	Output *string `json:"output,omitempty"`
}

// GetTotalSellByNameParams defines parameters for GetTotalSellByName.
type GetTotalSellByNameParams struct {
	Game1  *string `json:"game1,omitempty"`
	Game2  *string `json:"game2,omitempty"`
	Output *string `json:"output,omitempty"`
}

// GetTotalSellByPublisherParams defines parameters for GetTotalSellByPublisher.
type GetTotalSellByPublisherParams struct {
	Start      *int    `json:"start,omitempty"`
	End        *int    `json:"end,omitempty"`
	Publisher1 *string `json:"publisher1,omitempty"`
	Publisher2 *string `json:"publisher2,omitempty"`
	Output     *string `json:"output,omitempty"`
}

// GetTotalSellByYearsParams defines parameters for GetTotalSellByYears.
type GetTotalSellByYearsParams struct {
	Start  *int    `json:"start,omitempty"`
	End    *int    `json:"end,omitempty"`
	Output *string `json:"output,omitempty"`
}

// RegisterNewUserParams defines parameters for RegisterNewUser.
type RegisterNewUserParams struct {
	Firstname *string `json:"firstname,omitempty"`
	Lastname  *string `json:"lastname,omitempty"`
	Username  *string `json:"username,omitempty"`
	Password  *string `json:"password,omitempty"`
}

// Getter for additional properties for Meta. Returns the specified
// element and whether it was found
func (a Meta) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Meta
func (a *Meta) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Meta to handle AdditionalProperties
func (a *Meta) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Meta to handle AdditionalProperties
func (a Meta) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//+6FuUtxyMAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
